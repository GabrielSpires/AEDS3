#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes
\usepackage{tikz}
\date {}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language brazilian
\language_package none
\inputencoding auto
\fontencoding global
\font_roman times
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 3cm
\rightmargin 2.5cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
Trabalho Prático 3:
\series default
 Alimentação Saudável
\end_layout

\begin_layout Author
Gabriel Henrique Souto Pires {gabrielpires@ufmg.br}
\end_layout

\begin_layout Section
Introdução
\end_layout

\begin_layout Standard
O problema apresentado neste trabalho se refere ao 
\emph on
Problema da Soma dos Subconjuntos
\emph default
 
\emph on
(SubSet Sum Problem)
\emph default
 que trata de achar se em um dado conjunto de números inteiros, existe um
 subconjunto não vazio cujo a soma de seus elementos é 0.
 No caso deste trabalho prático é dado um valor inteiro que representa uma
 soma, um conjunto de inteiros e é pedido que se responda se é possível
 encontrar este número ao se somar os elementos de algum dos subconjuntos
 que podem ser gerados.
 Em caso positivo a palavra 
\begin_inset Quotes eld
\end_inset

sim
\begin_inset Quotes erd
\end_inset

 é exibida na tela, caso contrário é exibido 
\begin_inset Quotes eld
\end_inset

nao
\begin_inset Quotes erd
\end_inset

.
 No exemplo abaixo a resposta seria sim, uma vez que ao se somar os elementos
 do subconjunto 
\begin_inset Formula $\left[4,6,12,18\right]$
\end_inset

 acharemos a soma 
\begin_inset Formula $40$
\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename intro_conjuntos.pdf

\end_inset


\end_layout

\begin_layout Standard
O problema em questão tem várias solução que rodam em tempo pseudo-polinomial,
 mas o objetivo deste trabalho na verdade é implementar uma solução que
 possa utilizar programação paralela.
 Por isso uma solução não tão eficiente deveria ser implementada para que
 os benefícios da paralelização pudessem ser notados, então foi escolhida
 uma solução que utiliza força bruta para achar a resposta.
\end_layout

\begin_layout Section
Solução do Problema
\end_layout

\begin_layout Standard
Dado um número 
\emph on
S 
\emph default
que representa uma soma e um conjunto de números inteiros, a tarefa é dizer
 se existe um subconjunto do conjunto dado em que a soma de seus elementos
 seja igual a 
\emph on
S
\emph default
.
 A forma escolhida para se resolver esse problema foi usar o conjunto original
 para criar todas as suas combinações possíveis e então verificar um a um
 se a soma de seus elementos é igual à soma procurada.
 O algoritmo implementado é muito demorado se for executado de forma serial,
 por este motivo foram usadas várias threads para executar o programa de
 forma paralela.
\end_layout

\begin_layout Standard
Tecnicamente, uma thread é definida como um fluxo de instruções independente
 que pode ser programado para rodar de tal forma pelo sistema operacional.
 Imagine um programa principal que contém um número de procedimentos.
 Então imagine todos esses procedimentos sendo capazes de rodar simultâneamente
 e/ou independentemente pelo sistema operacional.
 Isso descreveria um programa 
\begin_inset Quotes eld
\end_inset

multi-threaded
\begin_inset Quotes erd
\end_inset

.
 Para implementar a paralelização neste trabalho, foi utilizada a biblioteca
 
\emph on
<pthread.h>
\emph default
.
 Pthread é o padrão POSIX para threads em sistemas UNIX.
\end_layout

\begin_layout Standard
Inicialmente, o programa é executado com o número de threads como argumento
 
\begin_inset Quotes eld
\end_inset


\emph on
./tp -t <threads>
\emph default

\begin_inset Quotes erd
\end_inset

, esse número então é usado para criar um vetor de threads do tipo 
\emph on
pthread_t
\emph default
.
 Então a entrada do programa é lida e armazenada em uma struct que mais
 tarde será usada para enviar os argumentos para a função a ser paralelizada.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4"
inline false
status open

\begin_layout Plain Layout

typedef struct{
\end_layout

\begin_layout Plain Layout

	int valores[310], //Vetor que armazena o conjunto
\end_layout

\begin_layout Plain Layout

	qtdV, //Variável que indica quantos elementos foram lidos
\end_layout

\begin_layout Plain Layout

	tamConjInicial,//Tamanho do primeiro subconjunto a ser gerado
\end_layout

\begin_layout Plain Layout

	tamConjFinal,//Tamanho do último subconjunto a ser gerado
\end_layout

\begin_layout Plain Layout

	soma;//Valor da soma 
\end_layout

\begin_layout Plain Layout

}Arg;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Struct usada para armezenar os valores
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depois de ler a entrada, é criado um vetor de structs do tipo 
\emph on
Arg 
\emph default
com
\emph on
 
\emph default
uma posição para cada thread, a entrada é então copiada para cada uma dessas
 structs no vetor ao mesmo tempo que é calculado o intervalo que cada thread
 irá calcular.
 Esse intervalo é calculado ao se dividir o número de valores lidos na entrada
 pelo numero de threads usadas, dessa forma cada thread gerará a mesma quantidad
e de subgrupos, com exceção da última thread, caso a quantidade de valores
 da entrada não seja um múltiplo do intervalo.
 Isso garante até certo nível que todas as threads terão a mesma quantidade
 de trabalho, mas se o tamanho dos grupos a serem gerados for levado em
 consideração fica claro que as threads que geram os grupos de tamanho mais
 próximo da metade do tamanho do vetor trabalharão mais, uma vez que são
 geradas mais combinações nesses casos já que na fórmula 
\begin_inset Formula $\frac{n!}{(n-k)!k!}$
\end_inset

 que representa as combinações, a quantidade de combinações cresce a medida
 que o valor de 
\emph on
k
\emph default
 (tamanho dos subgrupos) se aproxima da metade do valor de 
\emph on
n
\emph default
 (quantidade de valores).
 Isso pode representar uma degradação de desempenho por desbalanceamento
 de carga já que algumas threads trabalharão mais que outras.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename separacao_threads.pdf
	scale 85

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Representação da divisão de trabalho entre as threads
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O tipo de paralelismo implementado se caracteriza como paralelismo de dados,
 já que todas as threads trabalham com a mesma entrada fazendo a mesma tarefa
 que é gerar as combinações e verificar se a soma foi ou não encontrada.
\end_layout

\begin_layout Standard
Depois de calcular o intervalo de combinações que cada thread irá gerar,
 a função 
\emph on
pthread_create()
\emph default
 é chamada em um loop que vai de 0 até o número de threads.
 Em cada chamada dessa função são enviados uma das threads criadas no vetor
 no início do programa, o nome da função a ser paralelizada, e uma das structs
 criadas com a entrada e o intervalo a ser calculado pela thread.
 Assim como mostrado abaixo:
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4"
inline false
status open

\begin_layout Plain Layout

pthread_create(&threads[i], NULL, foo, &vetIn[i]);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Após chamar 
\emph on
pthread_create()
\emph default
 uma vez para cada thread, também é necessário chamar a função 
\emph on
pthread_join()
\emph default
 para as mesmas threads, para fazer com que o programa espere que todas
 as threads acabem de rodar antes de prosseguir com a execução.
 Caso isso não fosse feito, o programa poderia chegar ao fim e parar de
 executar antes que as threads finalizassem seu trabalho, fazendo com que
 a verificação das combinações fosse interrompida e a resposta errada fosse
 exibida.
\end_layout

\begin_layout Section
Análise Teórica do Custo Assintótico
\end_layout

\begin_layout Standard
A complexidade assintótica do programa será discutida na subseção abaixo.
\end_layout

\begin_layout Subsection
Análise Teórica do Custo Assintótico de Tempo
\end_layout

\begin_layout Subsection
Análise Teórica do Custo Assintótico de Espaço
\end_layout

\begin_layout Section
Análise Experimental do Custo Assintótico
\end_layout

\begin_layout Standard
Para fazer a análise experimental do programa, foi criado um outro programa
 que gera arquivos de entrada compatíveis de tamanhos variados de forma
 que a diferença do tempo de execução com entradas diferentes possa ser
 medido.
 Para não levar em consideração o tempo que se leva para digitar a entrada
 no tempo de execução do programa, a entrada foi lida diretamente dos arquivos.
 Para medir o tempo de execução do programa foi usada a biblioteca 
\emph on
time.h
\emph default
.
 Ao se criar uma variável do tipo 
\emph on
clock_t
\emph default
 e atribuindo à ela o valor que a função 
\emph on
clock()
\emph default
 retorna, o número de clocks necessários para executar o código pode ser
 obtido e exibido ao se transformar esse valor em um float e dividi-lo pela
 constante 
\emph on
CLOCKS_PER_SEC
\emph default
.
\end_layout

\begin_layout Standard
Os testes foram realizados em uma máquina virtual rodando Xubuntu 15.10.
 O computador utilizado tem um processador AMD Phenom II X4 965 3.40GHz e
 8GB de memória, porém, a máquina virtual utiliza apenas um núcleo do processado
r e 2GB de RAM.
\end_layout

\begin_layout Section
Conclusão
\end_layout

\end_body
\end_document
